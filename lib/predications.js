// Generated by CoffeeScript 1.10.0
var Predications, Range, SelectManager, exports, u;

u = require('underscore');

SelectManager = require('./select-manager');

Range = require('./range');

Predications = {
  nodes: function() {
    return require('./nodes/nodes');
  },
  as: function(other) {
    var lit, n;
    n = this.nodes();
    lit = new n.UnqualifiedName(other);
    return new n.As(this, lit);
  },
  notEq: function(other) {
    var n;
    n = this.nodes();
    return new n.NotEqual(this, other);
  },
  notEqAny: function(others) {
    return this.groupingAny('not_eq', others);
  },
  notEqAll: function(others) {
    return this.groupingAll('not_eq', others);
  },
  isNull: function() {
    return new (this.nodes()).IsNull(this);
  },
  notNull: function() {
    return new (this.nodes()).NotNull(this);
  },
  eq: function(other) {
    var n;
    n = this.nodes();
    return new n.Equality(this, other);
  },
  eqAny: function(others) {
    return this.groupingAny('eq', others);
  },
  eqAll: function(others) {
    return this.groupingAll('eq', others);
  },
  "in": function(other) {
    var n;
    n = this.nodes();
    switch (other.constructor) {
      case SelectManager:
        return new n.In(this, other.ast);
      case Range:
        return new n.Between(this, new n.And([other.start, other.finish]));
      default:
        return new n.In(this, other);
    }
  },
  inAny: function(others) {
    return this.groupingAny('in', others);
  },
  inAll: function(others) {
    return this.groupingAll('in', others);
  },
  notIn: function(other) {
    var n;
    n = this.nodes();
    switch (other.constructor) {
      case SelectManager:
        return new n.NotIn(this, other.ast);
      default:
        return new n.NotIn(this, other);
    }
  },
  notInAny: function(others) {
    return this.groupingAny('not_in', others);
  },
  notInAll: function(others) {
    return this.groupingAll('not_in', others);
  },
  matches: function(other) {
    var n;
    n = this.nodes();
    return new n.Matches(this, other);
  },
  matchesAny: function(others) {
    return this.groupingAny('matches', others);
  },
  matchesAll: function(others) {
    return this.groupingAll('matches', others);
  },
  doesNotMatch: function(other) {
    var n;
    n = this.nodes();
    return new n.DoesNotMatch(this, other);
  },
  doesNotMatchAny: function(others) {
    return this.groupingAny('does_not_match', others);
  },
  doesNotMatchAll: function(others) {
    return this.groupingAll('does_not_match', others);
  },
  gteq: function(right) {
    var n;
    n = this.nodes();
    return new n.GreaterThanOrEqual(this, right);
  },
  gteqAny: function(others) {
    return this.groupingAny('gteq', others);
  },
  gteqAll: function(others) {
    return this.groupingAll('gteq', others);
  },
  gt: function(right) {
    var n;
    n = this.nodes();
    return new n.GreaterThan(this, right);
  },
  gtAny: function(others) {
    return this.groupingAny('gt', others);
  },
  gtAll: function(others) {
    return this.groupingAll('gt', others);
  },
  lteq: function(right) {
    var n;
    n = this.nodes();
    return new n.LessThanOrEqual(this, right);
  },
  lteqAny: function(others) {
    return this.groupingAny('lteq', others);
  },
  lteqAll: function(others) {
    return this.groupingAll('lteq', others);
  },
  lt: function(right) {
    var n;
    n = this.nodes().LessThan;
    return new n(this, right);
  },
  ltAny: function(others) {
    return this.groupingAny('lt', others);
  },
  ltAll: function(others) {
    return this.groupingAll('lt', others);
  },
  like: function(right) {
    return new (this.nodes()).Like(this, right);
  },
  ilike: function(right) {
    return new (this.nodes()).ILike(this, right);
  },
  asc: function() {
    var n;
    n = this.nodes();
    return new n.Ordering(this, 'asc');
  },
  desc: function() {
    var n;
    n = this.nodes();
    return new n.Ordering(this, 'desc');
  },
  groupingAny: function(methodId, others) {
    var first, n;
    others = u(others).clone();
    first = others[methodId](others.shift());
    n = this.nodes();
    return new n.Grouping(u(others).reduce(first, function(memo, expr) {
      return new n.Or([memo, this[methodId](expr)]);
    }));
  },
  groupingAll: function(methodId, others) {
    var first, n;
    others = u(others).clone();
    first = others[methodId](others.shift());
    n = this.nodes();
    return new n.Grouping(u(others).reduce(first, function(memo, expr) {
      return new n.And([memo, this[methodId](expr)]);
    }));
  }
};

exports = module.exports = Predications;
